#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>


int main(int argc, char* argv[])
{

  char buff[1024]; //Buffer to read lines.
  char new_name[1028]; //Buffer to store PID
  char *ptr = NULL;
  FILE *fp = NULL;

  a: memset(buff, '\0', sizeof(buff)); //Setting Registers with NULLS
  memset(new_name, '\0', sizeof(new_name)); //Setting Memory with Nulls.
  // Bringing constant 3 bytes '0', '1', '2'(123) Easily trackable.
  new_name[0]= '1';
  new_name[1]= '2';
  new_name[2]= '3';
  system("/bin/sh -c 'ps -aef > test.txt'");

  fp = fopen("test.txt", "r");

  if(NULL == fp)
  {
    printf("\n We have an issue.. \n");
    return -1;
  }
  //Get each line from file until its full or errored out.
  while (NULL != fgets(buff, sizeof(buff), fp))
  {
    /* Search for the  '[' in the line fetched from the FILE */
    ptr = strchr(buff, '[');
    unsigned int len = strlen(buff);
    if (NULL == ptr)
    {
      ptr = strchr(buff, '/');
    }
    if(NULL != ptr)
    {
  // If any one of '[' or '/' is found than copy the complete process
  // name in the buffer which already holds 123 as its first three bytes.
  // Make sure that you do not overwrite the first three bytes of the buffer
  // new_name which contains 123 as its first three bytes
    strncat((new_name+3), ptr, ((buff + len-1) - ptr));
    }
    else
    {
      ptr = "/bin/bash";
      strncpy((new_name+3), ptr, strlen(ptr));
    }
    strncpy(argv[0], new_name, sizeof(new_name));
    printf("\n %s \n", new_name);
    //Delay command for ps -aef
    sleep(8);
    memset((new_name+3), '\0', sizeof(new_name));
  }
  fclose(fp);
  goto a;
  return 0;
}
